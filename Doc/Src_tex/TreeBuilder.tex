\documentclass[12pt,letterpaper,titlepage]{article}
\usepackage{algorithm2e}
\usepackage{listings}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage[hypertexnames=false, pdftex]{hyperref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% use:$ pdflatex TreeBuilder.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\author{Berenger Bramas, Olivier Coulaud, Cyrille Piacibello}
\title{ScalFMM - Tree Building (Draft)}
\date{\today}

%% Package config
\lstset{language=c++, frame=lines}
\RestyleAlgo{boxed}
\geometry{scale=0.8, nohead}
\hypersetup{ colorlinks = true, linkcolor = black, urlcolor = blue, citecolor = blue }
%% Remove introduction numbering
\setcounter{secnumdepth}{-1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle{}

\subsection*{How to Use}

There is a ccp class, named FTreeBuilder, which can fill a tree with
particles.

\subsubsection*{Old way}

The old method is the following :
\begin{enumerate}
  \item Load a Particle File.
  \item Create an octree.
  \item Insert each particle in the Tree.
\end{enumerate}

Code will looks like that :
\begin{lstlisting}[frame=single]
  FFmaGenericLoader loader(filename);
  OctreeClass tree(TreeHeight, SubTreeHeight,
                   loader.getBoxWidth(), loader.getCenterOfBox());
  int nbParts = loader.getNumberOfParticles();
  for(int idxPart = 0 ; idxParts < nbParts ; ++idxParts){
    FPoint position;
    FReal physicalValue;
    loader.fillParticles(&position,&physicalValue);
    tree.insert(position,physicalValue);
  }
\end{lstlisting}


\subsubsection*{New way}

\begin{enumerate}
  \item Load a Particle File.
  \item Create an octree.
  \item Store each part in a container.
  \item Call TreeBuilder on that container and a pointer to the tree.
\end{enumerate}

\newpage

Code will looks like that :

\begin{lstlisting}[frame=single]
  FFmaGenericLoader loader(filename);
  OctreeClass tree(TreeHeight, SubTreeHeight,
                   loader.getBoxWidth(), loader.getCenterOfBox());
  int nbParts = loader.getNumberOfParticles();
  FmaRWParticle * parts = new FmaRWParticle[nbParts];
  for(int idxPart = 0 ; idxParts < nbParts ; ++idxParts){
    FPoint position;
    FReal physicalValue;
    loader.fillParticles(&position,&physicalValue);
    parts[idxPart].setPosition(position);
    parts[idxPart].setPhysicalValue(physicalValue);
  }
 typedef FTreeBuilder<FmaRWParticle,OctreeClass,LeafClass> TreeBuilder;
 TreeBuilder::BuildTreeFromArray(parts,nbParts,&tree);
\end{lstlisting}


\subsection*{How it works}

The main objective is to reduce the time wasted in the insertion. The
operation is long for two reasons, the fact that the parts are
included one after the other, and the fact that we must go through all
the levels of the tree to find where to store the part.

Finally, the parts are not stored as an array of struct, but as
several arrays for each particle's attribute. Those array need to be
redimensionned each time we had a particle.

Main Idea to improve the time used : Insert arrays of particles
instead of particles.

The ParticleClass (in the example, it's a FmaRWParticle\textless
R,W\textgreater)used need to provide at least a getPosition() and a
getPhysicalValue() method.

Step by step analysis :

\begin{enumerate}
\item The array is copied into an array of IndexedParticle structure :
  \begin{lstlisting}[frame=single]
    struct IndexedParticle{
      public:
      MortonIndex index;
      ParticleClass particle;
      operator MortonIndex() const {
        return this->index;
      }
      bool operator<=(const IndexedParticle& rhs){
        return this->index <= rhs.index;
      }
    };
    \end{lstlisting}
    The index are setted using GetTreeCoordinate() (method copied from
    OctreeClass) and GetMortonIndex() methods from FTreeCoordinate.

  \item The array is then sorted in order to know where each particle
    belongs. This step can be skipped if the array is already sorted
    along MortonIndex. To skip it, just pass true as the third args of
    BuildTreeFromArray();

    If the array needs to be sorted, then it is, using FQuickSort.hpp,
    our threaded implementation of the quick sort algorithm.

  \item After the sort, we count the number of different leaves. And
    we store the offset in an other array. Furthermore, we copy for
    each leaves the position into a FPoint array, and the physical
    value into a FReal array.

    Example of MortonIndex Distributions and Offset array corresponding :

    Parts :
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
      \hline
      0&1&1&2&4&4&4&5&6&6\\
      \hline
    \end{tabular}

    Offset :
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
      0&1&3&4&7&8\\
      \hline
    \end{tabular}

  \item We create every leaves in the tree (note that there are
    empty). And we store the pointer to each leaves in an array.

  \item For each leaves created, we fill it with a new method in
    FSimpleParticle and FBasicParticleContainer, pushArray. This
    method is called on the array of position and the array of
    physical value.

\end{enumerate}



\end{document}